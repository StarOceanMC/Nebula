From cee35b602db78df7b8d4c802afa33b50913e6495 Mon Sep 17 00:00:00 2001
From: Lovely_xianxian <xyx_dada@outlook.com>
Date: Fri, 18 Sep 2020 23:38:49 +0800
Subject: [PATCH] Backport Fix Light Prioritization Patch

---
 .../minecraft/server/LightEngineThreaded.java | 45 ++++++++++++++-----
 1 file changed, 33 insertions(+), 12 deletions(-)

diff --git a/src/main/java/net/minecraft/server/LightEngineThreaded.java b/src/main/java/net/minecraft/server/LightEngineThreaded.java
index 9ef39f1f5..700d33eeb 100644
--- a/src/main/java/net/minecraft/server/LightEngineThreaded.java
+++ b/src/main/java/net/minecraft/server/LightEngineThreaded.java
@@ -14,12 +14,13 @@ import org.apache.logging.log4j.Logger;
 public class LightEngineThreaded extends LightEngine implements AutoCloseable {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final ThreadedMailbox<Runnable> b; ThreadedMailbox<Runnable> mailbox; // Paper
+    private final ThreadedMailbox<Runnable> b;
     // Paper start
     private static final int MAX_PRIORITIES = PlayerChunkMap.GOLDEN_TICKET + 2;
+    private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> priorityChanges = new java.util.concurrent.ConcurrentLinkedQueue<>();
 
     public void changePriority(long pair, int currentPriority, int priority) {
-        this.mailbox.queue(() -> {
+        this.priorityChanges.add(() -> {
             ChunkLightQueue remove = this.queue.buckets[currentPriority].remove(pair);
             if (remove != null) {
                 ChunkLightQueue existing = this.queue.buckets[priority].put(pair, remove);
@@ -31,6 +32,15 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
         });
     }
 
+    private boolean isChunkLightStatus(long pair) {
+        PlayerChunk playerChunk = playerChunkMap.getUpdatingChunk(pair);
+        if (playerChunk == null) {
+            return false;
+        }
+        ChunkStatus status = PlayerChunk.getChunkStatus(playerChunk.getTicketLevel());
+        return status != null && status.isAtLeastStatus(ChunkStatus.LIGHT);
+    }
+
     static class ChunkLightQueue {
         public boolean shouldFastUpdate;
         java.util.ArrayDeque<Runnable> pre = new java.util.ArrayDeque<Runnable>();
@@ -41,7 +51,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
 
 
     // Retain the chunks priority level for queued light tasks
-    private static class LightQueue {
+    private class LightQueue {
         private int size = 0;
         private int lowestPriority = MAX_PRIORITIES;
         private final it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = new it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
@@ -106,7 +116,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
 
     private final LightQueue queue = new LightQueue();
     // Paper end
-    private final PlayerChunkMap d;
+    private final PlayerChunkMap d; private final PlayerChunkMap playerChunkMap; // Paper
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> e;
     private volatile int f = 5;
     private final AtomicBoolean g = new AtomicBoolean();
@@ -114,8 +124,9 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
     public LightEngineThreaded(ILightAccess ilightaccess, PlayerChunkMap playerchunkmap, boolean flag, ThreadedMailbox<Runnable> threadedmailbox, Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailbox) {
         super(ilightaccess, true, flag);
         this.d = playerchunkmap;
+        this.playerChunkMap = playerchunkmap;
         this.e = mailbox;
-        this.mailbox = this.b = threadedmailbox; // Paper
+        this.b = threadedmailbox; // Paper
     }
 
     public void close() {}
@@ -204,10 +215,6 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
             // Paper start
             int priority = intsupplier.getAsInt();
             this.queue.add(ChunkCoordIntPair.pair(i, j), priority, lightenginethreaded_update, runnable); // Paper
-            if (priority <= 25) { // don't auto kick off unless priority
-                // Paper end
-                this.b();
-            }
 
         }, ChunkCoordIntPair.pair(i, j), intsupplier));
     }
@@ -226,14 +233,27 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
     public CompletableFuture<IChunkAccess> a(IChunkAccess ichunkaccess, boolean flag) {
         ChunkCoordIntPair chunkcoordintpair = ichunkaccess.getPos();
 
-        ichunkaccess.b(false);
+        //ichunkaccess.b(false); // Don't need to disable this
         // Paper start
         long pair = chunkcoordintpair.pair();
         CompletableFuture<IChunkAccess> future = new CompletableFuture<>();
-        IntSupplier prioritySupplier1 = d.getPrioritySupplier(pair);
+        IntSupplier prioritySupplier1 = playerChunkMap.getPrioritySupplier(pair);
         IntSupplier prioritySupplier = flag ? () -> Math.max(1, prioritySupplier1.getAsInt() - 10) : prioritySupplier1;
         this.e.a(ChunkTaskQueueSorter.a(() -> {
+            // Chunk's no longer needed
+            if (!isChunkLightStatus(pair)) {
+                this.d.c(chunkcoordintpair); // copied from end of method to release light ticket
+                future.complete(ichunkaccess);
+                return;
+            }
+            boolean[] skippedPre = {false};
             this.queue.add(pair, prioritySupplier.getAsInt(), LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+                if (!isChunkLightStatus(pair)) {
+                    this.d.c(chunkcoordintpair); // copied from end of method to release light ticket
+                    future.complete(ichunkaccess);
+                    skippedPre[0] = true;
+                    return;
+                }
                 // Paper end
             ChunkSection[] achunksection = ichunkaccess.getSections();
 
@@ -252,13 +272,14 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
                 });
             }
 
-            this.d.c(chunkcoordintpair);
+            this.d.c(chunkcoordintpair); // Paper - if change, copy into !isChunkLightStatus above
         }, () -> {
             return "lightChunk " + chunkcoordintpair + " " + flag;
             // Paper start  - merge the 2 together
         }));
 
         this.queue.add(pair, prioritySupplier.getAsInt(), LightEngineThreaded.Update.POST_UPDATE, () -> {
+            if (skippedPre[0]) return; // Paper - future's already complete
             ichunkaccess.b(true);
             super.b(chunkcoordintpair, false);
             // Paper start
-- 
2.27.0

